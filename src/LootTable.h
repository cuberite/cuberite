
#pragma once

#include "Item.h"
#include "json/json.h"
#include "Noise/Noise.h"
#include "LootTableParser.h"

/*
This is a representation of the loot tables as described in the wiki:
https://minecraft.gamepedia.com/Loot_table
The json files are parsed every time on startup.

Notes:
	01.09.2020:
		Vanilla Minecraft uses a luck value per player that influences the outcome.
		This is not added to cuberite at the moment.
		I noted where you need to add some code (search for: "TODO: Luck")
	06.09.2020:
		When updating the loot tables you have to check the Tag interpretation. There might be new items added.
		There is a link to the list in the minecraft wiki in the LootTable class.
	16.09.2020:
		*--------------------------------------------------------------*
		|                                                              |
		| 				Maintaining instructions                       |
		|                                                              |
		* -------------------------------------------------------------*
		The LootTable.cpp and LootTableProvider.cpp are just a nice interface. The heavy lifting is done in LootTableParser.cpp

		So there are multiple things to maintain:
		- A new entry type:
		If you want to add or edit a entry type you need to add this to the enum in LootTableParser.
		Additional you need to add the handling to the ParseLootTableEntry() and GetItems() in the LootTable.
		- A new function, condition:
		If you want to add or edit a function you need to add a new class to the matching namespace in LootTableParser.
		Additional you need to add it to the respective VISIT macro.
	16.09.2020:
		*--------------------------------------------------------------*
		|                                                              |
		|   Things left to do resulting from missing implementation    |
		|                                                              |
		* -------------------------------------------------------------*
		- Anything NBT related
		- Treasure enchantments
		- Json Text components for item name and item lore
		- Luck in the rolls evaluation
*/

// fwd:
class cWorld;
class cBlockHandler;
class cBlockEntity;


/** A individual loot table */
class cLootTable
{
public:
	/** Creates a empty loot table */
	cLootTable() = default;

	/** Creates new loot table from a Json object describing the loot table */
	cLootTable(const Json::Value & a_Description);

	cLootTable(const cLootTable & a_Other) = default;
	cLootTable(cLootTable && a_Other) = default;
	cLootTable & operator = (const cLootTable & a_Other) = default;
	cLootTable & operator = (cLootTable && a_Other) = default;

	/** Fills the specified item grid. Needs world and pos for randomisation and access to player. */
	bool FillWithLoot(cItemGrid & a_ItemGrid, cWorld & a_World, const Vector3i a_Pos, const UInt32 a_PlayerID, int a_Seed) const;

	// Note: For any function killed describes the entity which triggered the event. And Killer the entity which killed the entity (if applicable)
	/** Returns cItems with all the items generated by the loot table */
	cItems GetItems(const cNoise & a_Noise, const Vector3i & a_Pos, cWorld & a_World, UInt32 a_KilledID, UInt32 a_KillerID, const TakeDamageInfo & a_DamageSource, int a_ExplosionSize = 0) const;

protected:
	/** contained loot pools */
	LootTable::cLootTablePools m_LootTablePools;

	/** Vector of functions applied to all pools */
	LootTable::cLootTableFunctions m_Functions;

private:
	static cItems GetItems(const LootTable::cLootTablePool & a_Pool, cWorld & a_World, const cNoise & a_Noise, const Vector3i & a_Pos, UInt32 a_KilledID, UInt32 a_KillerID, const TakeDamageInfo & a_DamageSource, int a_ExplosionSize);

	static cItems GetItems(const LootTable::cLootTablePoolEntry & a_Entry, cWorld & a_World, const cNoise & a_Noise, const Vector3i & a_Pos, UInt32 a_KilledID, UInt32 a_KillerID, const TakeDamageInfo & a_DamageSource, int a_ExplosionSize);

	static bool ConditionsApply(const LootTable::cLootTableConditions & a_Conditions, cWorld & a_World, const cNoise & a_Noise, const Vector3i a_Pos, UInt32 a_KilledID, UInt32 a_KillerID, const TakeDamageInfo & a_DamageSource, int a_ExplosionSize);

	static bool ConditionApplies(const LootTable::cLootTableCondition & a_Condition, cWorld & a_World, const cNoise & a_Noise, const Vector3i a_Pos, UInt32 a_KilledID, UInt32 a_KillerID, const TakeDamageInfo & a_DamageSource, int a_ExplosionSize);

	/** Applies given function to an item */
	static void ApplyFunction(const LootTable::cLootTableFunction & a_Function, cItem & a_Item, cWorld & a_World, const cNoise & a_Noise, const Vector3i & a_Pos, UInt32 a_KilledID, UInt32 a_KillerID, const TakeDamageInfo & a_DamageSource, int a_ExplosionSize);
};
typedef std::unordered_map<AString, cLootTable> cLootTables;




